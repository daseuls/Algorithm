8 / 30

> 선생님이 n명의 학생을 일렬로 세웠습니다. 일렬로 서 있는 학생의 키가 앞에서부터 순서대로 주어질때, 맨 앞에 서 있는 학생의 키가 앞에서부터 순서대로 주어질 때, 맨 앞에 서 있는 선생님이 볼 수 있는 학생의 수를 수하는 프로그램을 작성하세요.(앞에 서 있는 사람들보다 크면 보이고, 작거나 같으면 보이지 않습니다.)

- 문제 접근 방법

배열안에 학생의 키 숫자들이 들어있는데, 자기 자신보다 앞에 있는 요소들보다 자신이 제일 큰 요소들의 개수를 구한다.

- 첫 번째로 풀었던 방법 (실패함....)

이중 for문을 이용해 첫번째 for문은 맨 뒤의 요소부터 앞 요소로 반복문을 돌린 후 그 안에 인덱스 1부터 시작하여 첫번째 for문의 인덱스보다 작은 요소값들을 비교한다 .
예를 들어 요소가 6개라고 가정했을때, index[5]와 index[1],[2],[3],[4]를 비교, index[4]와 index[1],[2],[3]를 비교 ... 반복 !
여기서 index[1]부터 시작한 이유는 index[0]은 무조건 값을 셀수 있기 때문에 제외하고 count를 1부터 시작한다.

```javascript
const getTallerStudent = (arr) => {
  let num = 0
  for (let i = arr.length - 1; i > 0; i--) {
    for (let j = 0; j < i; i++) {
      if (arr[i] > arr[j]) {
        // 여기서 막혔다....
      }
    }
  }
}
```

앞의 모든 요소보다 클때를 조건으로 걸어야 하는데 각 각 하나씩 요소들을 비교할 수 밖에 없게 되어서, 어떻게 접근해야 할지 멘붕,,,이었지만 다시 생각해보기 !!!

for문을 하나만 쓰고도 풀수 있는 방법이 있다!!
이중 for문보다 시간복잡도도 줄일 수 있다.

```javascript
const getTallerStudent = (arr) => {
  let max = arr[0]
  let result = 1
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      result++
      max = arr[i]
    }
  }
  return result
}

console.log(getTallerStudent([133, 140, 125, 165, 187, 178])) // 4
```

- 풀이

1. max라는 변수에 배열의 가장 첫번째 요소를 할당한다.
2. result에 1을 할당한다. 이유는 가장 첫번째 요소는 무조건 보이기 때문이다.
3. index 1부터 시작해서 마지막 요소까지 for문을 통해 돌면서 만약 arr[i]가 max값보다 크다면 result에 1을 더하고, max의 값을 arr[i]값으로 바꿔준다. 이렇게 되면 뒤의 요소로 반복문이 지나가는 동안 가장 큰 값과 index의 값을 비교할 수 있기 때문에 그 값보다 클 경우 result를 하나씩 증가시킬수 있다.
